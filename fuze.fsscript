//// Build: 180323T200400.095Z



//// //// //// //// Bootstrap/Init.fs

namespace Fuze

#nowarn "20"

open System.Diagnostics
open System.Runtime.CompilerServices
type TracerA() =
    static member trace(  args,
                            [<CallerMemberName>] ?memberName: string,
                            [<CallerFilePath>]   ?path: string,
                            [<CallerLineNumber>] ?line: int            )  =
        match (memberName, path, line) with
        | Some m, Some p, Some l ->
            printfn "[:%s:%6i] %s( %A )" "fuze.fsscript" l m args
        | _,_,_ -> ()

type zlog(args :obj) =
    do
        printfn "zlog: %A" args



module Fuze =
    open System.Diagnostics
    open System.Runtime.CompilerServices


module Init =
    let init args =
        printfn "init( %A )" args



//// //// //// //// _ANY/fake.fs

namespace Fake
module Fake1=
    printfn ""






//// //// //// //// _ANY/core.fs

namespace Fake
module Core1=

    printfn ""



//// //// //// //// Core/String.fs

    /// Contains basic functions for string manipulation.
namespace Fuze.Core
[<RequireQualifiedAccess>]
module String=
    type String = System.String

    open System
    open System.IO
    open System.Text
    open System.Collections.Generic


    /// [omit]
    let productName() = "FUZE"

    /// Returns if the string is null or empty
    let inline isNullOrEmpty value = String.IsNullOrEmpty value

    /// Returns if the string is not null or empty
    let inline isNotNullOrEmpty value = String.IsNullOrEmpty value |> not

    /// Returns if the string is null or empty or completely whitespace
    let inline isNullOrWhiteSpace value = isNullOrEmpty value || value |> Seq.forall Char.IsWhiteSpace

    /// Replaces the given pattern in the given text with the replacement
    let inline replace (pattern : string) replacement (text : string) = text.Replace(pattern, replacement)

    /// Converts a sequence of strings to a string with delimiters
    let inline separated (delimiter:string) (items : string seq) = String.Join(delimiter, Array.ofSeq items)

    /// Removes the slashes from the end of the given string
    let inline trimSlash (s : string) = s.TrimEnd('\\')

    /// Splits the given string at the given char delimiter
    let inline split (delimiter : char) (text : string) = text.Split [| delimiter |] |> Array.toList

    /// Splits the given string at the given string delimiter
    let inline splitStr (delimiterStr : string) (text : string) = 
        text.Split([| delimiterStr |], StringSplitOptions.None) |> Array.toList

    /// Converts a sequence of strings into a string separated with line ends
    // let inline toLines text = separated Environment.NewLine text

    /// Checks whether the given text starts with the given prefix
    let startsWith (prefix:string) (text : string) = text.StartsWith prefix

    /// Checks whether the given text ends with the given suffix
    let endsWith (suffix:string) (text : string) = text.EndsWith suffix

    /// Determines whether the last character of the given <see cref="string" />
    /// matches Path.DirectorySeparatorChar.         
    let endsWithSlash = endsWith (Path.DirectorySeparatorChar.ToString())

    /// Replaces the first occurrence of the pattern with the given replacement.
    let replaceFirst (pattern : string) replacement (text : string) = 
        let pos = text.IndexOf pattern
        if pos < 0 then text
        else text.Remove(pos, pattern.Length).Insert(pos, replacement)

    /// [omit]
    let private regexes = new Dictionary<_, _>()

    /// [omit]
    let getRegEx pattern = 
        match regexes.TryGetValue pattern with
        | true, regex -> regex
        | _ -> (new System.Text.RegularExpressions.Regex(pattern))

    /// [omit]
    let regex_replace pattern (replacement : string) text = (getRegEx pattern).Replace(text, replacement)

    /// Checks whether the given char is a german umlaut.
    let isUmlaut c = Seq.exists ((=) c) [ '?'; '?'; '?'; '?'; '?'; '?'; '?' ]

    /// Converts all characters in a string to lower case.
    let inline toLower (s : string) = s.ToLower()

    /// Returns all standard chars and digits.
    let charsAndDigits = [ 'a'..'z' ] @ [ 'A'..'Z' ] @ [ '0'..'9' ]

    /// Checks whether the given char is a standard char or digit.
    let isLetterOrDigit c = List.exists ((=) c) charsAndDigits

    /// Trims the given string with the DirectorySeparatorChar
    let inline trimSeparator (s : string) = s.TrimEnd Path.DirectorySeparatorChar

    /// Trims all special characters from a string.
    let inline trimSpecialChars (text : string) = 
        text
        |> Seq.filter isLetterOrDigit
        |> Seq.filter (isUmlaut >> not)
        |> Seq.fold (fun (acc : string) c -> acc + string c) ""

    /// Trims the given string
    let inline trim (x : string) = 
        if isNullOrEmpty x then x
        else x.Trim()

    /// Trims the given string
    let inline trimChars (chars :char[]) (x : string) = 
        if isNullOrEmpty x then x
        else x.Trim chars

    /// Trims the start of the given string
    let inline trimStartChars (chars :char[]) (x : string) =
        if isNullOrEmpty x then x
        else x.TrimStart chars

    /// Trims the end of the given string
    let inline trimEndChars (chars :char[]) (x : string) =
        if isNullOrEmpty x then x
        else x.TrimEnd chars

    /// Lifts a string to an option
    let liftString x = 
        if isNullOrEmpty x then None
        else Some x


    /// Removes all trailing .0 from a version string
    let rec NormalizeVersion(version : string) =
        if version = null then "" else
        let elements = version.Split [| '.' |]
        let mutable version = ""
        for i in 0..3 do
            if i < elements.Length then 
                if version = "" then version <- elements.[i]
                else version <- version + "." + elements.[i]
        if version.EndsWith ".0" then version.Remove(version.Length - 2, 2) |> NormalizeVersion
        else version

    let Colon = ','


    /// Represents Linux line breaks
    let LinuxLineBreaks = "\n"

    /// Represents Windows line breaks
    let WindowsLineBreaks = "\r\n"

    /// Represents Mac line breaks
    let MacLineBreaks = "\r"

    /// Converts all line breaks in a text to windows line breaks
    let ConvertTextToWindowsLineBreaks text = 
        text
        |> replace WindowsLineBreaks LinuxLineBreaks
        |> replace MacLineBreaks LinuxLineBreaks
        |> replace LinuxLineBreaks WindowsLineBreaks

    /// Reads a file line by line and replaces all line breaks to windows line breaks
    ///   - uses a temp file to store the contents in order to prevent OutOfMemory exceptions
    let ConvertFileToWindowsLineBreaksWithEncoding (encoding:System.Text.Encoding) (fileName : string) =
        let tempFileName = Path.GetTempFileName()
        ( use file = File.OpenRead fileName 
          use reader = new StreamReader(file, encoding)
          ( use tempFile = File.Open(tempFileName, FileMode.Create)
            use writer = new StreamWriter(tempFile, encoding)
            while not reader.EndOfStream do
                reader.ReadLine()
                |> ConvertTextToWindowsLineBreaks
                |> writer.WriteLine))
        File.Delete(fileName)
        File.Move(tempFileName, fileName)
        
    let ConvertFileToWindowsLineBreak (encoding:System.Text.Encoding) (fileName : string) =
      ConvertFileToWindowsLineBreaksWithEncoding Encoding.UTF8 fileName

    /// Removes linebreaks from the given string
    let inline RemoveLineBreaks text = 
        text
        |> replace "\r" String.Empty
        |> replace "\n" String.Empty

    /// Encapsulates the Apostrophe
    let inline EncapsulateApostrophe text = replace "'" "`" text

    /// Decodes a Base64-encoded UTF-8-encoded string
    let DecodeBase64Utf8String(text : string) = 
        text
        |> Convert.FromBase64String
        |> Encoding.UTF8.GetString

    module Operators =
        /// Checks whether the given text starts with the given prefix
        let inline (<*) prefix text = startsWith prefix text
        
        /// Find a regex pattern in a text and replaces it with the given replacement.
        let (>=>) pattern replacement text = regex_replace pattern replacement text

        /// Determines if a text matches a given regex pattern.
        let (>**) pattern text = (getRegEx pattern).IsMatch text



//// //// //// //// Shell/Path.fs

   /// Contains helper function which allow to deal with files and directories.
namespace Fuze.IO
[<RequireQualifiedAccess>]
module Path=

    open Fuze.Core
    open Fuze.Core.String.Operators
    open System
    open System.IO
    open System.Collections.Generic

    /// Combines two path strings using Path.Combine
    let inline combineTrimEnd path1 (path2 : string) = Path.Combine(path1, path2.TrimStart [| '\\'; '/' |])
    /// Combines two path strings using Path.Combine
    let inline combine path1 path2 = Path.Combine(path1, path2)

    /// Detects whether the given path is a directory.
    let isDirectory path = 
        let attr = File.GetAttributes path
        attr &&& FileAttributes.Directory = FileAttributes.Directory
        
    /// Detects whether the given path is a file.
    let isFile path = isDirectory path |> not

    /// Normalizes a filename.
    let normalizeFileName (fileName : string) =
        let dirsepChar = Path.DirectorySeparatorChar
        let dirsep = dirsepChar.ToString()
        fileName
            .Replace("\\", dirsep)
            .Replace("/", dirsep)
            .TrimEnd(dirsepChar)
            .ToLower()


    /// Detects whether the given path does not contains invalid characters.
    let isValidPath (path:string) =
        Path.GetInvalidPathChars()
        |> Array.exists (fun char -> path.Contains(char.ToString()))
        |> not

    /// Change the extension of the file.
    /// ## Parameters
    ///
    /// - 'extension' - The new extension containing the leading '.'.
    /// - 'fileName' - Name of the file from which the extension is retrieved.
    let changeExtension extension fileName = Path.ChangeExtension(fileName, extension)

    /// Tests whether the file has specified extensions (containing the leading '.')
    /// ## Parameters
    ///
    /// - 'extension' - The extension to fine containing the leading '.'.
    /// - 'fileName' - Name of the file from which the extension is retrieved.
    let hasExtension extension fileName = System.String.Equals(Path.GetExtension fileName, extension, System.StringComparison.OrdinalIgnoreCase)

    /// Get the directory of the specified path
    /// ## Parameters
    ///
    /// - 'path' - The path from which the directory is retrieved.
    let getDirectory path = Path.GetDirectoryName path

    /// The directory separator string. On most systems / or \
    let directorySeparator =
        let dirsepChar = Path.DirectorySeparatorChar
        dirsepChar.ToString()

    let getFullName p = Path.GetFullPath p

    /// Replaces any occurence of the currentDirectory with .
    let inline shortenCurrentDirectory path = String.replace (Directory.GetCurrentDirectory()) "." path

    /// <summary>Produces relative path when possible to go from baseLocation to targetLocation.</summary>
    /// <param name="baseLocation">The root folder</param>
    /// <param name="targetLocation">The target folder</param>
    /// <returns>The relative path relative to baseLocation</returns>
    /// <exception cref="ArgumentNullException">base or target locations are null or empty</exception>
    let private ProduceRelativePath baseLocation targetLocation = 
        if String.isNullOrEmpty baseLocation then raise (new ArgumentNullException "baseLocation")
        if String.isNullOrEmpty targetLocation then raise (new ArgumentNullException "targetLocation")
        if not <| Path.IsPathRooted baseLocation then baseLocation
        else if not <| Path.IsPathRooted targetLocation then targetLocation
        else if String.Compare(Path.GetPathRoot baseLocation, Path.GetPathRoot targetLocation, true) <> 0 then 
            targetLocation
        else if String.Compare(baseLocation, targetLocation, true) = 0 then "."
        else 
            let resultPath = ref "."
            
            let targetLocation = 
                if targetLocation |> String.endsWith directorySeparator then targetLocation
                else targetLocation + directorySeparator
            
            let baseLocation = 
                if baseLocation |> String.endsWith directorySeparator then ref (baseLocation.Substring(0, baseLocation.Length - 1))
                else ref baseLocation
            
            while not <| targetLocation.StartsWith(!baseLocation + directorySeparator, StringComparison.OrdinalIgnoreCase) do
                resultPath := !resultPath + directorySeparator + ".."
                baseLocation := Path.GetDirectoryName !baseLocation
                if (!baseLocation) |> String.endsWith directorySeparator then 
                    baseLocation := (!baseLocation).Substring(0, (!baseLocation).Length - 1)
            resultPath 
            := (!resultPath + targetLocation.Substring((!baseLocation).Length)) 
                |> String.replace (directorySeparator + directorySeparator) directorySeparator
            // preprocess .\..\ case
            if (sprintf ".%s..%s" directorySeparator directorySeparator) <* (!resultPath) then 
                (!resultPath).Substring(2, (!resultPath).Length - 3)
            else (!resultPath).Substring(0, (!resultPath).Length - 1)

    let toRelativeFrom =
        /// A cache of relative path names.
        /// [omit]
        let relativePaths = new Dictionary<_, _>()

        /// Replaces the absolute path to a relative path.
        let inline toRelativePath basePath value =
            let key = (basePath, value)
            match relativePaths.TryGetValue key with
            | true, x -> x
            | _ -> 
                let x = ProduceRelativePath basePath value
                relativePaths.Add(key, x)
                x

        toRelativePath

    let toRelativeFromCurrent path =
        let currentDir = normalizeFileName <| Directory.GetCurrentDirectory()
        toRelativeFrom currentDir path

    /// Convert the given windows path to a path in the current system
    let convertWindowsToCurrentPath (windowsPath : string) = 
        if (windowsPath.Length > 2 && windowsPath.[1] = ':' && windowsPath.[2] = '\\') then windowsPath
        else windowsPath.Replace(@"\", directorySeparator)
        



//// //// //// //// Shell/FileSystemOperators.fs

namespace Fuze.IO

open System.IO

module FileSystemOperators =
    /// Combines two path strings using Path.Combine
    let inline (@@) path1 path2 = Path.combineTrimEnd path1 path2
    /// Combines two path strings using Path.Combine
    let inline (</>) path1 path2 = Path.combine path1 path2



//// //// //// //// Shell/DirectoryInfo.fs

namespace Fuze.IO

open System.IO
open Fuze.IO.FileSystemOperators

[<RequireQualifiedAccess>]
module DirectoryInfo =
    /// Creates a DirectoryInfo for the given path.
    let inline ofPath path = DirectoryInfo(path)

    /// Gets all subdirectories of a given directory.
    let inline getSubDirectories (dir : DirectoryInfo) = dir.GetDirectories()

    /// Gets all files in the directory.
    let inline getFiles (dir : DirectoryInfo) = dir.GetFiles()

    /// Finds all the files in the directory matching the search pattern.
    let getMatchingFiles pattern (dir : DirectoryInfo) = 
        if dir.Exists then dir.GetFiles pattern
        else [||]

        
    /// Finds all the files in the directory and in all subdirectories matching the search pattern.
    let getMatchingFilesRecursive pattern (dir : DirectoryInfo) = 
        if dir.Exists then dir.GetFiles(pattern, SearchOption.AllDirectories)
        else [||]
        
    /// Checks if dir1 is a subfolder of dir2. If dir1 equals dir2 the function returns also true.
    let rec isSubfolderOf (dir2 : DirectoryInfo) (dir1 : DirectoryInfo) = 
        if Path.normalizeFileName dir1.FullName = Path.normalizeFileName dir2.FullName then true
        else if isNull dir1.Parent then false
        else dir1.Parent |> isSubfolderOf dir2
        
    /// Checks if the file is in a subfolder of the dir.
    let containsFile (fileInfo : FileInfo) (dir : DirectoryInfo) = isSubfolderOf dir fileInfo.Directory
    
    /// Checks if the directory exists on disk.
    let exists (dir : DirectoryInfo) = dir.Exists
    
    /// Ensure that directory chain exists. Create necessary directories if necessary.
    let inline ensure (dir : DirectoryInfo) =
        if not dir.Exists then dir.Create()
 
    /// Performs the given actions on all files and subdirectories
    let rec private recursively dirF fileF (dir : DirectoryInfo) = 
        dir
        |> getSubDirectories
        |> Seq.iter (fun dir -> 
               recursively dirF fileF dir
               dirF dir)
        dir
        |> getFiles
        |> Seq.iter fileF

    /// Sets the directory readonly 
    let setReadOnly readOnly (dir : DirectoryInfo) = 
        if dir.Exists then 
            let isReadOnly = dir.Attributes &&& FileAttributes.ReadOnly = FileAttributes.ReadOnly
            if readOnly && (not isReadOnly) then dir.Attributes <- dir.Attributes ||| FileAttributes.ReadOnly
            if (not readOnly) && not isReadOnly then dir.Attributes <- dir.Attributes &&& (~~~FileAttributes.ReadOnly)

    /// Sets all files in the directory readonly recursively.
    let setReadOnlyRecursive readOnly dir = 
        recursively (setReadOnly readOnly) (fun file -> file.IsReadOnly <- readOnly) dir
    
    /// Copies the file structure recursively, filtering files.
    let rec copyRecursiveToWithFilter overwrite filter (outputDir : DirectoryInfo) (dir : DirectoryInfo) = 
        let files = 
            dir
            |> getSubDirectories
            |> Seq.fold (fun acc (d : DirectoryInfo) -> 
                   let newDir = outputDir.FullName @@ d.Name
                                |> ofPath
                   ensure newDir
                   d
                   |> copyRecursiveToWithFilter overwrite filter newDir
                   |> fun r -> r @ acc) []
        (dir
         |> getFiles
         |> Seq.filter (fun f -> filter outputDir f)
         |> Seq.map (fun f -> 
                let newFileName = outputDir.FullName @@ f.Name
                f.CopyTo(newFileName, overwrite) |> ignore
                newFileName)
         |> Seq.toList) @ files

    /// Copies the file structure recursively.
    let copyRecursiveTo overwrite (outputDir : DirectoryInfo) (dir : DirectoryInfo) = copyRecursiveToWithFilter overwrite (fun _ _ -> true) outputDir dir



//// //// //// //// Shell/FileInfo.fs

namespace Fuze.IO

open System.IO

[<RequireQualifiedAccess>]
module FileInfo =
    /// Creates a FileInfo for the given path.
    let inline ofPath path = new FileInfo(path)
    
    /// Active Pattern for determining file name.
    let (|FullName|) (f : FileInfo) = f.FullName

    /// Active Pattern for determining FileInfoNameSections.
    let (|NameSections|) (f : FileInfo) = (f.Name, f.Extension, f.FullName)
    
    /// Checks if the two files are byte-to-byte equal.
    let contentIsEqualTo (first : FileInfo) (second : FileInfo) = 
        if first.Length <> second.Length then false
        else 
            let BYTES_TO_READ = 32768
            use fs1 = first.OpenRead()
            use fs2 = second.OpenRead()
            let one = Array.create BYTES_TO_READ (byte 0)
            let two = Array.create BYTES_TO_READ (byte 0)
            let mutable eq = true
            while eq && fs1.Read(one, 0, BYTES_TO_READ) <> 0 && fs2.Read(two, 0, BYTES_TO_READ) <> 0 do
                if one <> two then eq <- false
            eq

    



//// //// //// //// Shell/Directory.fs

namespace Fuze.IO

open System.IO

[<RequireQualifiedAccess>]
module Directory =

    /// Checks if the given directory exists. If not then this functions creates the directory.
    let inline ensure dir =
        dir |> DirectoryInfo.ofPath |> DirectoryInfo.ensure

    /// Creates a directory if it does not exist.
    let create = ensure

    /// Gets the first file in the directory matching the search pattern as an option value.
    let tryFindFirstMatchingFile pattern dir = 
        dir
        |> DirectoryInfo.ofPath
        |> DirectoryInfo.getMatchingFiles pattern
        |> fun files -> 
            if Seq.isEmpty files then None
            else (Seq.head files).FullName |> Some

    /// Gets the first file in the directory matching the search pattern or throws an error if nothing was found.
    let findFirstMatchingFile pattern dir = 
        match tryFindFirstMatchingFile pattern dir with
        | Some x -> x
        | None -> FileNotFoundException(sprintf "Could not find file matching %s in %s" pattern dir) |> raise
        
    /// Deletes a directory if it exists (including all contained elements).
    let delete path = 
        let dir = DirectoryInfo.ofPath path
        if dir.Exists then 
            DirectoryInfo.setReadOnlyRecursive false dir
            dir.Delete true



//// //// //// //// Shell/File.fs

/// Contains helpers which allow to interact with the file system.
namespace Fuze.IO

open System.Text
open System.IO
open Fuze.Core
open Operators

[<RequireQualifiedAccess>]
module FileFilter =
    let allFiles _ = true

[<RequireQualifiedAccess>]
module File =

    // Detect the encoding, from https://stackoverflow.com/questions/3825390/effective-way-to-find-any-files-encoding
    let getEncoding def filename = 
        // Read the BOM
        let bom = Array.zeroCreate 4
        let read =
            use file = new FileStream(filename, FileMode.Open, FileAccess.Read)
            file.Read(bom, 0, 4)
            
        match bom |> Array.toList with
        | _ when read < 2 -> def
        | 0xffuy :: 0xfeuy :: _ -> Encoding.Unicode //UTF-16LE
        | 0xfeuy :: 0xffuy :: _ -> Encoding.BigEndianUnicode //UTF-16BE
        | _ when read < 3 -> def
        | 0x2buy :: 0x2fuy :: 0x76uy :: _ -> Encoding.UTF7
        | 0xefuy :: 0xbbuy :: 0xbfuy :: _ -> Encoding.UTF8
        | _ when read < 4 -> def
        | 0uy :: 0uy :: 0xfeuy :: 0xffuy :: _ -> Encoding.UTF32
        | _ -> def


    /// Checks if the file exists on disk.
    let exists fileName = File.Exists fileName

    /// Gets the encoding from the file or the default of the file doesn't exist
    let getEncodingOrDefault def filename =
        if not (exists filename) then def
        else getEncoding def filename

    /// Raises an exception if the file doesn't exist on disk.
    let checkExists fileName = 
        if not <| exists fileName then 
            FileNotFoundException(sprintf "File %s does not exist." fileName) |> raise

    /// Checks if all given files exist.
    let allExist files = Seq.forall File.Exists files

    /// Get the version a file.
    /// ## Parameters
    ///
    ///  - 'fileName' - Name of file from which the version is retrieved. The path can be relative.
    let getVersion (fileName : string) = 
        Path.getFullName fileName
        |> System.Diagnostics.FileVersionInfo.GetVersionInfo
        |> fun x -> x.FileVersion.ToString()

    /// Creates a file if it does not exist.
    let create fileName = 
        let file = FileInfo.ofPath fileName
        if not file.Exists then 
            file.Create() |> ignore

    /// Deletes a file if it exists.
    let delete fileName = 
        let file = FileInfo.ofPath fileName
        if file.Exists then 
            file.Delete()

    /// Deletes the given files.
    let deleteAll files = Seq.iter delete files

    /// Active Pattern for determining file extension.
    let (|EndsWith|_|) (extension : string) (file : string) = 
        if file.EndsWith extension then Some()
        else None
        
    /// Reads a file line by line
    let readWithEncoding (encoding : Encoding) (file : string) = 
        seq {
            use stream = File.OpenRead(file)
            use textReader = new StreamReader(stream, encoding)
            while not textReader.EndOfStream do
                yield textReader.ReadLine()
        }
    let read (file : string) = readWithEncoding (getEncodingOrDefault Encoding.UTF8 file) file
    
    /// Reads the first line of a file. This can be helpful to read a password from file.
    let readLineWithEncoding (encoding:Encoding) (file : string) =
        use stream = File.OpenRead file
        use sr = new StreamReader(stream, encoding)
        sr.ReadLine()

    /// Reads the first line of a file. This can be helpful to read a password from file.
    let readLine(file : string) = readLineWithEncoding (getEncodingOrDefault Encoding.UTF8 file) file

    /// Writes a file line by line
    let writeWithEncoding (encoding:Encoding) append fileName (lines : seq<string>) =
        let fi = FileInfo.ofPath fileName
        use file = fi.Open(if append then FileMode.Append else FileMode.Create)
        use writer = new StreamWriter(file, encoding)
        lines |> Seq.iter writer.WriteLine

    let write append fileName (lines : seq<string>) = writeWithEncoding (getEncodingOrDefault Encoding.UTF8 fileName) append fileName lines
        
    /// Writes a byte array to a file
    let writeBytes file bytes = File.WriteAllBytes(file, bytes)

    /// Writes a string to a file
    let writeStringWithEncoding (encoding:Encoding) append fileName (text : string) = 
        let fi = FileInfo.ofPath fileName
        use file = fi.Open(if append then FileMode.Append else FileMode.Create)
        use writer = new StreamWriter(file, encoding)
        writer.Write text

    let writeString append fileName (text : string) = writeStringWithEncoding (getEncodingOrDefault Encoding.UTF8 fileName) append fileName text

    /// Replaces the file with the given string
    let replaceContent fileName text = 
        let fi = FileInfo.ofPath fileName
        if fi.Exists then 
            fi.IsReadOnly <- false
            fi.Delete()
        writeString false fileName text

    /// Writes a file line by line
    let writeNew file lines = write false file lines

    /// Appends all lines to a file line by line
    let append file lines = write true file lines

    /// Reads a file as one text
    let inline readAsStringWithEncoding encoding file = File.ReadAllText(file, encoding)
    let inline readAsString file = File.ReadAllText(file, (getEncodingOrDefault Encoding.UTF8 file))

    /// Reads a file as one array of bytes
    let readAsBytes file = File.ReadAllBytes file

    /// Replaces the text in the given file
    let applyReplace replaceF fileName = 
        fileName
        |> readAsString
        |> replaceF
        |> replaceContent fileName




//// //// //// //// Shell/FileSystemInfo.fs

namespace Fuze.IO

open System
open System.IO


[<RequireQualifiedAccess>]
module FileSystemInfo =
    /// Creates a FileInfo or a DirectoryInfo for the given path
    let inline ofPath path : FileSystemInfo = 
        if Directory.Exists path then upcast DirectoryInfo.ofPath path
        else upcast FileInfo.ofPath path
    
    /// Sets all given files or directories readonly.
    let SetReadOnly readOnly (items : string seq) = 
        items |> Seq.iter (fun item ->
            let fi = FileInfo.ofPath item
            if fi.Exists then fi.IsReadOnly <- readOnly
            else 
                item
                |> DirectoryInfo.ofPath
                |> DirectoryInfo.setReadOnly readOnly)

    /// Active pattern which discriminates between files and directories.
    let (|File|Directory|) (fileSysInfo : FileSystemInfo) = 
        match fileSysInfo with
        | :? FileInfo as file -> File(file)
        | :? DirectoryInfo as dir -> Directory(dir, dir.EnumerateFileSystemInfos())
        | _ -> failwith "No file or directory given."



//// //// //// //// Shell/Globbing.fs

    /// This module contains a file pattern globbing implementation.
namespace Fuze.IO.Globbing
module Glob=

    open System
    open System.Collections.Generic
    open System.IO
    open System.Text.RegularExpressions


    // Normalizes path for different OS
    let inline normalizePath (path : string) = 
        path.Replace('\\', Path.DirectorySeparatorChar).Replace('/', Path.DirectorySeparatorChar)

    type private SearchOption = 
        | Directory of string
        | Drive of string
        | Recursive
        | FilePattern of string

    let private checkSubDirs absolute (dir : string) root = 
        if dir.Contains "*" then Directory.EnumerateDirectories(root, dir, SearchOption.TopDirectoryOnly) |> Seq.toList
        else 
            let path = Path.Combine(root, dir)
            
            let di = 
                if absolute then new DirectoryInfo(dir)
                else new DirectoryInfo(path)
            if di.Exists then [ di.FullName ]
            else []

    let rec private buildPaths acc (input : SearchOption list) = 
        match input with
        | [] -> acc
        | Directory(name) :: t -> 
            let subDirs = 
                acc
                |> List.map (checkSubDirs false name)
                |> List.concat
            buildPaths subDirs t
        | Drive(name) :: t -> 
            let subDirs = 
                acc
                |> List.map (checkSubDirs true name)
                |> List.concat
            buildPaths subDirs t
        | Recursive :: [] -> 
            let dirs = 
                Seq.collect (fun dir -> Directory.EnumerateFileSystemEntries(dir, "*", SearchOption.AllDirectories)) acc 
                |> Seq.toList
            buildPaths (acc @ dirs) []
        | Recursive :: t -> 
            let dirs = 
                Seq.collect (fun dir -> Directory.EnumerateDirectories(dir, "*", SearchOption.AllDirectories)) acc 
                |> Seq.toList
            buildPaths (acc @ dirs) t
        | FilePattern(pattern) :: t -> 
             Seq.collect (fun dir -> 
                                if Directory.Exists(Path.Combine(dir, pattern))
                                then seq { yield Path.Combine(dir, pattern) }
                                else 
                                    try
                                        Directory.EnumerateFiles(dir, pattern)
                                    with
                                        | :? System.IO.PathTooLongException as ex ->
                                            Array.toSeq [| |]
                                ) acc |> Seq.toList

    let private driveRegex = Regex(@"^[A-Za-z]:$", RegexOptions.Compiled)

    let inline private normalizeOutputPath (p : string) = 
        p.Replace('\\', Path.DirectorySeparatorChar).Replace('/', Path.DirectorySeparatorChar)
         .TrimEnd(Path.DirectorySeparatorChar)

    let internal getRoot (baseDirectory : string) (pattern : string) =
        let baseDirectory = normalizePath baseDirectory
        let normPattern = normalizePath pattern

        let patternParts = normPattern.Split([| '/'; '\\' |], StringSplitOptions.RemoveEmptyEntries)
        let patternPathParts = 
            patternParts
            |> Seq.takeWhile(fun p -> not (p.Contains("*")))
            |> Seq.toArray

        let globRoot = 
            // If we did not find any "*", then drop the last bit (it is a file name, not a pattern)
            ( if patternPathParts.Length = patternParts.Length then
                  patternPathParts.[0 .. patternPathParts.Length-2]     
              else patternPathParts )
            |> String.concat (Path.DirectorySeparatorChar.ToString())

        let globRoot = 
            // If we dropped "/" from the beginning of the path in the 'Split' call, put it back!
            if normPattern.StartsWith("/") then "/" + globRoot
            else globRoot

        if Path.IsPathRooted globRoot then globRoot
        else Path.Combine(baseDirectory, globRoot)

    let internal search (baseDir : string) (input : string) = 
        let baseDir = normalizePath baseDir
        let input = normalizePath input
        let input = input.Replace(baseDir, "")

        let filePattern = Path.GetFileName(input)
        input.Split([| '/'; '\\' |], StringSplitOptions.RemoveEmptyEntries)
        |> Seq.map (function 
               | "**" -> Recursive
               | a when a = filePattern -> FilePattern(a)
               | a when driveRegex.IsMatch a -> Directory(a + "\\")
               | a -> Directory(a))
        |> Seq.toList
        |> buildPaths [ baseDir ]
        |> List.map normalizeOutputPath

    let internal compileGlobToRegex pattern =
        let pattern = normalizePath pattern

        let escapedPattern = (Regex.Escape pattern)
        let regexPattern = 
            let xTOy = 
                [
                    "dirwildcard", (@"\\\*\\\*(/|\\\\)", @"(.*(/|\\))?")
                    "stardotstar", (@"\\\*\\.\\\*", @"([^\\/]*)")
                    "wildcard", (@"\\\*", @"([^\\/]*)")
                ] |> List.map(fun (key, reg) ->
                    let pattern, replace = reg
                    let pattern = sprintf "(?<%s>%s)" key pattern
                    key, (pattern, replace)
                )
            let xTOyMap = xTOy |> Map.ofList
            let replacePattern = xTOy |> List.map(fun x -> x |> snd |> fst) |> String.concat("|")
            let replaced = Regex(replacePattern).Replace(escapedPattern, fun m -> 
                let matched = xTOy |> Seq.map(fst) |> Seq.find(fun n -> 
                    m.Groups.Item(n).Success
                )
                (xTOyMap |> Map.tryFind matched).Value |> snd
            )
            "^" + replaced + "$"

        Regex(regexPattern)

    let private globRegexCache = System.Collections.Concurrent.ConcurrentDictionary<string, Regex>()

    let isMatch pattern path : bool = 
        let path = normalizePath path

        let regex = 
            let outRegex : ref<Regex> = ref null
            if globRegexCache.TryGetValue(pattern, outRegex) then
                !outRegex
            else
                let compiled = compileGlobToRegex pattern
                globRegexCache.TryAdd(pattern, compiled) |> ignore
                compiled

        regex.IsMatch(path)



//// //// //// //// Shell/GlobbingFileSystem.fs

/// This module contains a file pattern globbing implementation.
namespace Fuze.IO
open System.Collections.Generic

type IGlobbingPattern =
    inherit IEnumerable<string>
    abstract BaseDirectory : string
    abstract Includes : string list
    abstract Excludes : string list

namespace Fuze.IO.Globbing
open Fuze.IO
open System.Collections.Generic

type LazyGlobbingPattern =
    { BaseDirectory : string
      Includes : string list
      Excludes : string list }
    
    interface IGlobbingPattern with
        member this.BaseDirectory = this.BaseDirectory
        member this.Includes = this.Includes
        member this.Excludes = this.Excludes

    interface IEnumerable<string> with
        
        member this.GetEnumerator() = 
            let hashSet = HashSet()
            
            let excludes = 
                seq { 
                    for pattern in this.Excludes do
                        yield! Glob.search this.BaseDirectory pattern
                }
                |> Set.ofSeq
            
            let files = 
                seq { 
                    for pattern in this.Includes do
                        yield! Glob.search this.BaseDirectory pattern
                }
                |> Seq.filter (fun x -> not (Set.contains x excludes))
                |> Seq.filter (fun x -> hashSet.Add x)
            
            files.GetEnumerator()
        
        member this.GetEnumerator() = (this :> IEnumerable<string>).GetEnumerator() :> System.Collections.IEnumerator

type ResolvedGlobbingPattern =
    { BaseDirectory : string
      Includes : string list
      Excludes : string list
      Results : string list }
    
    interface IGlobbingPattern with
        member this.BaseDirectory = this.BaseDirectory
        member this.Includes = this.Includes
        member this.Excludes = this.Excludes

    interface IEnumerable<string> with
        member this.GetEnumerator() = (this.Results :> IEnumerable<string>).GetEnumerator()
        member this.GetEnumerator() = (this :> IEnumerable<string>).GetEnumerator() :> System.Collections.IEnumerator

namespace Fuze.IO
open System.IO
open Fuze.IO.Globbing

[<AutoOpen>] // A bit of a hack but we need those extensions for backwards compat.
module GlobbingPatternExtensions =
    type IGlobbingPattern with
        member internal this.Pattern =
            match this with
            | :? LazyGlobbingPattern as l -> l
            | _ ->
                { BaseDirectory = this.BaseDirectory
                  Includes = this.Includes
                  Excludes = this.Excludes }
        member this.Resolve() =
            match this with
            | :? ResolvedGlobbingPattern as res -> res :> IGlobbingPattern
            | _ ->
                let list =
                    this
                    |> Seq.toList
                { BaseDirectory = this.BaseDirectory
                  Includes = this.Includes
                  Excludes = this.Excludes
                  Results = list } :> IGlobbingPattern
        /// Adds the given pattern to the file includes
        member this.And pattern = { this.Pattern with Includes = this.Includes @ [ pattern ] } :> IGlobbingPattern
        
        /// Ignores files with the given pattern
        member this.ButNot pattern = { this.Pattern with Excludes = pattern :: this.Excludes } :> IGlobbingPattern
        
        /// Sets a directory as BaseDirectory.
        member this.SetBaseDirectory(dir : string) = { this.Pattern with BaseDirectory = dir.TrimEnd(Path.DirectorySeparatorChar) } :> IGlobbingPattern
        
        /// Checks if a particular file is matched
        member this.IsMatch (path : string) =
            let fullDir pattern = 
                if Path.IsPathRooted(pattern) then
                    pattern
                else
                    System.IO.Path.Combine(this.BaseDirectory, pattern)
            let fullPath = Path.GetFullPath path
            let included = 
                this.Includes
                |> Seq.exists(fun fileInclude ->
                    Glob.isMatch (fullDir fileInclude) fullPath
                )
            let excluded = 
                this.Excludes
                |> Seq.exists(fun fileExclude ->
                    Glob.isMatch (fullDir fileExclude) fullPath
                )

            included && not excluded


[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module GlobbingPattern =
    let private defaultBaseDir = Path.GetFullPath "."

    /// Include files
    let Include x = 
        { BaseDirectory = defaultBaseDir
          Includes = [ x ]
          Excludes = [] } :> IGlobbingPattern

    /// Sets a directory as baseDirectory for fileIncludes. 
    let SetBaseDir (dir : string) (fileIncludes : IGlobbingPattern) = fileIncludes.SetBaseDirectory dir

    /// Get base include directories. Used to get a smaller set of directories from a globbing pattern.
    let GetBaseDirectoryIncludes (fileIncludes: IGlobbingPattern) =
            let directoryIncludes = fileIncludes.Includes |> Seq.map (fun file -> Globbing.Glob.getRoot fileIncludes.BaseDirectory file)

            // remove subdirectories
            directoryIncludes
            |> Seq.filter (fun d ->
                            directoryIncludes
                            |> Seq.exists (fun p -> d.StartsWith p && p <> d)
                            |> not)
            |> Seq.toList

namespace Fuze.IO.Globbing

open Fuze.IO
open System.IO

// Compat
[<System.Obsolete("Please use IGlobbingPattern instead")>]
type FileIncludes = IGlobbingPattern

[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
[<System.Obsolete("Please use GlobbingPattern instead")>]
module FileIncludes =
    /// Include files
    [<System.Obsolete("Please use GlobbingPattern instead")>]
    let Include x = GlobbingPattern.Include x

    /// Sets a directory as baseDirectory for fileIncludes. 
    [<System.Obsolete("Please use GlobbingPattern instead")>]
    let SetBaseDir (dir : string) (fileIncludes : IGlobbingPattern) = GlobbingPattern.SetBaseDir dir fileIncludes

module Operators =
    /// Add Include operator
    let inline (++) (x : IGlobbingPattern) pattern = x.And pattern

    /// Exclude operator
    let inline (--) (x : IGlobbingPattern) pattern = x.ButNot pattern

    /// Includes a single pattern and scans the files - !! x = AllFilesMatching x
    let inline (!!) x = GlobbingPattern.Include x

module Tools =
    open Operators

    let private (@@) path1 (path2:string) = Path.Combine(path1, path2.TrimStart [| '\\'; '/' |])

    /// Looks for a tool first in its default path, if not found the in ./packages/ and then
    /// in all subfolders of the root folder - returns the tool file name.
    let findToolInSubPath (toolname:string) (defaultPath:string) =
        try
            let tools = !! (defaultPath @@ "/**/" @@ toolname)
            if  Seq.isEmpty tools then 
                let packages = !! ("./packages/**/" @@ toolname)
                if Seq.isEmpty packages then
                    let root = !! ("./**/" @@ toolname)
                    Seq.head root
                else
                    Seq.head packages
            else
                Seq.head tools
        with
        | _ -> defaultPath @@ toolname

    /// Looks for a tool in all subfolders - returns the folder where the tool was found.
    let findToolFolderInSubPath toolname defaultPath =
        try
            let tools = !! ("./**/" @@ toolname)
            if Seq.isEmpty tools then defaultPath
            else 
                let fi = FileInfo (Seq.head tools)
                fi.Directory.FullName
        with
        | _ -> defaultPath



//// //// //// //// Shell/Templates.fs

    /// NOTE: Maybe this should be an extra module?
    /// Contains basic templating functions. Used in other helpers.
namespace Fuze.IO
[<RequireQualifiedAccess>]
module Templates=

    /// Loads all templates (lazy - line by line!)
    let load seq = Seq.map (fun fileName -> fileName, File.read fileName) seq

    /// Replaces a bunch of the keywords in all files (lazy - line by line!)
    let replaceKeywords replacements =
        Seq.map (fun (fileName, file) ->
            fileName,
            file |> Seq.map (fun (line : string) ->
                        let mutable sb = new System.Text.StringBuilder(line)
                        for (k : string, r : string) in replacements do
                            sb <- sb.Replace(k, r)
                        sb.ToString()))

    /// Saves all files (lazy - file by file!)
    let saveFiles = Seq.iter (fun (fileName, file) -> File.write false fileName (Seq.toList file))

    /// Replaces the templates with the given replacements
    let replaceInFiles replacements files =
        files
        |> load
        |> replaceKeywords replacements
        |> saveFiles



//// //// //// //// Shell/Shell.fs

/// Shell-like functions. Similar to [Ruby's FileUtils](http://www.ruby-doc.org/stdlib-2.0.0/libdoc/rake/rdoc/FileUtils.html).
namespace Fuze.IO

open System.IO
open Fuze.Core
open Fuze.IO.FileSystemOperators

[<RequireQualifiedAccess>]
module Shell =

    /// Copies a single file to the target and overwrites the existing file.
    /// ## Parameters
    ///
    ///  - `target` - The target directory or file.
    ///  - `fileName` - The FileName.
    let CopyFile target fileName =
        let fi = FileSystemInfo.ofPath fileName
        match fi with
        | FileSystemInfo.File f ->
            let targetName =
                match FileSystemInfo.ofPath target with
                | FileSystemInfo.Directory _ -> target @@ fi.Name
                | FileSystemInfo.File f' -> f'.FullName
            //TODO: logVerbosefn "Copy %s to %s" fileName targetName
            f.CopyTo(targetName, true) |> ignore
        | FileSystemInfo.Directory _ -> () //TODO: logVerbosefn "Ignoring %s, because it is a directory." fileName

    let private DoCopyFile targetName fileName =
        let fi = FileInfo.ofPath fileName
        let target = FileInfo.ofPath targetName
        DirectoryInfo.ensure target.Directory
        //TODO: logVerbosefn "Copy %s to %s" fileName targetName
        fi.CopyTo(targetName, true) |> ignore

    /// Copies a single file to a relative subfolder of the target.
    /// ## Parameters
    ///
    ///  - `target` - The target directory
    ///  - `fileName` - The fileName
    let CopyFileIntoSubFolder target fileName =
        let relative = (Path.toRelativeFromCurrent fileName).TrimStart '.'
        DoCopyFile (target + relative) fileName

    /// Copies a single file to the target folder preserving the folder structure
    /// starting from the specified base folder.
    /// ## Parameters
    ///
    ///  - `baseDir` - The base directory.
    ///  - `target` - The target directory.
    ///  - `fileName` - The file name.
    let CopyFileWithSubfolder baseDir target fileName =
        let fileName = Path.GetFullPath fileName
        let baseDir = Path.GetFullPath baseDir
        let relative = (Path.toRelativeFrom baseDir fileName).TrimStart '.'
        DoCopyFile (target + relative) fileName

    /// Copies the files to the target.
    /// ## Parameters
    ///
    ///  - `target` - The target directory.
    ///  - `files` - The original file names as a sequence.
    let Copy target files =
        Directory.ensure target
        files |> Seq.iter (CopyFile target)

    /// Copies the given files to the target.
    /// ## Parameters
    ///
    ///  - `target` - The target directory.
    ///  - `files` - The original file names as a sequence.
    let CopyTo target files = Copy target files

    /// Copies the files from a cache folder.
    /// If the files are not cached or the original files have a different write time the cache will be refreshed.
    /// ## Parameters
    ///
    ///  - `target` - The target FileName.
    ///  - `cacheDir` - The cache directory.
    ///  - `files` - The orginal files.
    let CopyCached target cacheDir files =
        let cache = DirectoryInfo.ofPath cacheDir
        DirectoryInfo.ensure cache
        files
        |> Seq.map (fun fileName ->
               let fi = FileInfo.ofPath fileName
               let cached = cacheDir @@ fi.Name
               let cachedFi = FileInfo.ofPath cached

               let originalExists =
                   try
                       fi.Exists
                   with exn -> false
               if not originalExists then
                   if not cachedFi.Exists then failwithf "Original file %s and cached file %s do not exist." fileName cached
                   else () //TODO: tracefn "Original file %s does not exist, using cached file %s." fileName cached
               else if not cachedFi.Exists || cachedFi.LastWriteTime <> fi.LastWriteTime then
                   () //TODO: tracefn "Cached file %s doesn't exist or is not up to date. Copying file to cache." cached
                   CopyFile cacheDir fi.FullName
               else () //TODO: tracefn "Cached file %s is up to date." cached
               CopyFile target cached
               target @@ fi.Name)
        |> Seq.toList

    /// Renames the file or directory to the target name.
    /// ## Parameters
    ///
    ///  - `target` - The target file or directory name.
    ///  - `fileName` - The orginal file or directory name.
    let Rename target fileName = (FileInfo.ofPath fileName).MoveTo target

    /// Copies a list of files to the specified directory without any output.
    /// ## Parameters
    ///
    ///  - `target` - The target directory.
    ///  - `files` - List of files to copy.
    let SilentCopy target files =
        files |> Seq.iter (fun file ->
                     let fi = FileInfo.ofPath file
                     let targetName = target @@ fi.Name
                     let targetFI = FileInfo.ofPath targetName
                     if targetFI.Exists then
                         if fi.LastWriteTime > targetFI.LastWriteTime then
                             targetFI.Attributes <- FileAttributes.Normal
                             fi.CopyTo(targetName, true) |> ignore
                     else fi.CopyTo(targetName) |> ignore)

    /// Copies the files to the target - Alias for Copy
    /// ## Parameters
    ///
    ///  - `target` - The target directory.
    ///  - `files` - The orginal file names.
    let CopyFiles target files = Copy target files


    /// Copies a directory recursivly. If the target directory does not exist, it will be created.
    /// ## Parameters
    ///
    ///  - `target` - The target directory.
    ///  - `source` - The source directory.
    ///  - `filterFile` - A file filter predicate.
    let CopyDir target source filterFile =
        Directory.ensure target
        Directory.GetFiles(source, "*.*", SearchOption.AllDirectories)
        |> Seq.filter filterFile
        |> Seq.iter (fun file ->
               let fi =
                   file
                   |> String.replaceFirst source ""
                   |> String.trimSeparator

               let newFile = target @@ fi
               () //TODO: logVerbosefn "%s => %s" file newFile
               Path.getDirectory newFile |> Directory.ensure
               File.Copy(file, newFile, true))
        |> ignore

    /// Cleans a directory by removing all files and sub-directories.
    let CleanDir path =
        let di = DirectoryInfo.ofPath path
        if di.Exists then
            () //TODO: logfn "Deleting contents of %s" path
            // delete all files
            Directory.GetFiles(path, "*.*", SearchOption.AllDirectories) |> Seq.iter (fun file ->
                                                                                let fi = FileInfo.ofPath file
                                                                                fi.IsReadOnly <- false
                                                                                fi.Delete())
            // deletes all subdirectories
            let rec deleteDirs actDir =
                Directory.GetDirectories(actDir) |> Seq.iter deleteDirs
                Directory.Delete(actDir, true)
            Directory.GetDirectories path |> Seq.iter deleteDirs
        else Directory.ensure path
        // set writeable
        File.SetAttributes(path, FileAttributes.Normal)

    /// Cleans multiple directories
    let CleanDirs dirs = Seq.iter CleanDir dirs

    /// Compat
    let DeleteDir dir = Directory.delete dir

    /// Deletes multiple directories
    let DeleteDirs dirs = Seq.iter Directory.delete dirs

    /// Appends all given files to one file.
    /// ## Parameters
    ///
    ///  - `newFileName` - The target FileName.
    ///  - `files` - The original FileNames as a sequence.
    let AppendTextFilesWithEncoding encoding newFileName files =
        let fi = FileInfo.ofPath newFileName
        if fi.Exists then failwithf "File %s already exists." (fi.FullName)
        use file = fi.Open(FileMode.Create)
        use writer = new StreamWriter(file, encoding)
        files |> Seq.iter (File.read >> Seq.iter writer.WriteLine)
                     //() //TODO: logVerbosefn "Appending %s to %s" file fi.FullName
                     //)

    /// Appends all given files to one file.
    /// ## Parameters
    ///
    ///  - `newFileName` - The target FileName.
    ///  - `files` - The original FileNames as a sequence.
    let AppendTextFiles newFileName files = AppendTextFilesWithEncoding System.Text.Encoding.UTF8 newFileName files

    /// Compares the given files for changes.
    /// If delete is set to true then equal files will be removed.
    let CompareFiles delete originalFileName compareFileName =
        let ori = FileInfo.ofPath originalFileName
        let comp = FileInfo.ofPath compareFileName

        let identical =
            if not (ori.Exists && comp.Exists && ori.Length = comp.Length) then false
            else ori.LastWriteTime = comp.LastWriteTime || FileInfo.contentIsEqualTo ori comp
        if not identical then false
        else
            if delete then
                comp.Attributes <- FileAttributes.Normal
                comp.Delete()
                () //TODO: logVerbosefn "Deleting File: %s" comp.FullName
            else () //TODO: logVerbosefn "Files equal: %s" comp.FullName
            true

    /// Checks the srcFiles for changes to the last release.
    /// ## Parameters
    ///
    ///  - `lastReleaseDir` - The directory of the last release
    ///  - `patchDir` - The target directory
    ///  - `srcFiles` - The source files
    ///  - `findOldFileF` - A function which finds the old file
    let GeneratePatchWithFindOldFileFunction lastReleaseDir patchDir srcFiles findOldFileF =
        let i = ref 0
        for file in srcFiles do
            let newFile = Path.toRelativeFromCurrent file
            let oldFile = findOldFileF newFile (lastReleaseDir + newFile.TrimStart('.'))
            let fi = FileInfo.ofPath oldFile
            if not fi.Exists then () //TODO: logVerbosefn "LastRelease has no file like %s" fi.FullName
            if CompareFiles false oldFile newFile |> not then
                i := !i + 1
                CopyFileIntoSubFolder patchDir newFile
        () //TODO: tracefn "Patch contains %d files." !i

    /// Checks the srcFiles for changes to the last release.
    /// ## Parameters
    ///
    ///  - `lastReleaseDir` - The directory of the last release.
    ///  - `patchDir` - The target directory.
    ///  - `srcFiles` - The source files.
    let GeneratePatch lastReleaseDir patchDir srcFiles =
        GeneratePatchWithFindOldFileFunction lastReleaseDir patchDir srcFiles (fun _ b -> b)

    /// Checks if the directory exists
    let TestDir path =
        let di = DirectoryInfo.ofPath path
        if di.Exists then true
        else
            () //TODO: logfn "%s not found" di.FullName
            false

    /// Checks if the file exists
    let TestFile path =
        let fi = FileInfo.ofPath path
        if fi.Exists then true
        else
            () //TODO: logfn "%s not found" fi.FullName
            false


    /// Copies the file structure recursively.
    let CopyRecursive dir outputDir overWrite = DirectoryInfo.copyRecursiveTo overWrite (DirectoryInfo.ofPath outputDir) (DirectoryInfo.ofPath dir)
    let inline CopyRecursiveTo overWrite outputDir dir  = CopyRecursive dir outputDir overWrite

    [<NoComparison; NoEquality>]
    type CopyRecursiveMethod =
    | Overwrite
    | NoOverwrite
    | Skip
    | IncludePattern of string
    | ExcludePattern of string
    | Filter of (DirectoryInfo -> FileInfo -> bool)

    open Fuze.IO.Globbing.Glob
    /// Copies the file structure recursively.
    /// ## Parameters
    /// 
    ///  - `method` - the method to decide which files get copied
    ///  - `dir` - The source directory.
    ///  - `outputDir` - The target directory.
    let CopyRecursive2 method dir outputDir =
        let dirInfo = DirectoryInfo.ofPath dir
        let outputDirInfo = DirectoryInfo.ofPath outputDir   
        let copyRecursiveWithFilter f = DirectoryInfo.copyRecursiveToWithFilter false f outputDirInfo dirInfo
        match method with
        | Overwrite -> DirectoryInfo.copyRecursiveTo true dirInfo outputDirInfo
        | NoOverwrite -> DirectoryInfo.copyRecursiveTo false dirInfo outputDirInfo
        | Skip -> copyRecursiveWithFilter <| fun d f -> d.FullName @@ f.Name |> File.Exists |> not
        | IncludePattern(pattern) ->
            copyRecursiveWithFilter <| fun d f -> d.FullName @@ f.Name |> (isMatch pattern)
        | ExcludePattern(pattern) ->
            copyRecursiveWithFilter <| fun d f -> d.FullName @@ f.Name |> (isMatch pattern) |> not
        | Filter(f) -> copyRecursiveWithFilter f

    /// Moves a single file to the target and overwrites the existing file.
    /// ## Parameters
    ///
    ///  - `target` - The target directory.
    ///  - `fileName` - The FileName.
    let MoveFile target fileName =
        let fi = FileSystemInfo.ofPath fileName
        match fi with
        | FileSystemInfo.File f ->
            let targetName = target @@ fi.Name
            let targetInfo = FileInfo.ofPath targetName
            if targetInfo.Exists then targetInfo.Delete()
            () //TODO: logVerbosefn "Move %s to %s" fileName targetName
            f.MoveTo(targetName) |> ignore
        | FileSystemInfo.Directory _ -> () //TODO: logVerbosefn "Ignoring %s, because it is a directory." fileName

    /// Creates a config file with the parameters as "key;value" lines
    let WriteConfigFile configFileName parameters =
        if String.isNullOrEmpty configFileName then ()
        else
            let fi = FileInfo.ofPath configFileName
            if fi.Exists then fi.Delete()
            use streamWriter = fi.CreateText()
            for (key, value) in parameters do
                streamWriter.WriteLine("{0};{1}", key, value)

    /// Replaces all occurences of the patterns in the given files with the given replacements.
    /// ## Parameters
    ///
    ///  - `replacements` - A sequence of tuples with the patterns and the replacements.
    ///  - `files` - The files to process.
    let ReplaceInFiles replacements files = Templates.replaceInFiles replacements files

    /// Replace all occurences of the regex pattern with the given replacement in the specified file
    /// ## Parameters
    ///
    /// - `pattern` - The string to search for a match
    /// - `replacement` - The replacement string
    /// - `encoding` - The encoding to use when reading and writing the file
    /// - `file` - The path of the file to process
    let RegexReplaceInFileWithEncoding pattern (replacement:string) encoding file =
        let oldContent = File.ReadAllText(file, encoding)
        let newContent = System.Text.RegularExpressions.Regex.Replace(oldContent, pattern, replacement)
        File.WriteAllText(file, newContent, encoding)

    /// Replace all occurences of the regex pattern with the given replacement in the specified files
    /// ## Parameters
    ///
    /// - `pattern` - The string to search for a match
    /// - `replacement` - The replacement string
    /// - `encoding` - The encoding to use when reading and writing the files
    /// - `files` - The paths of the files to process
    let RegexReplaceInFilesWithEncoding pattern (replacement:string) encoding files =
        files |> Seq.iter (RegexReplaceInFileWithEncoding pattern replacement encoding)


    /// Deletes a file if it exists
    let rm fileName = File.delete fileName

    /// Like "rm -rf" in a shell. Removes files recursively, ignoring nonexisting files
    let rm_rf f =
        if Directory.Exists f then Directory.delete f
        else File.delete f

    /// Creates a directory if it doesn't exist.
    let mkdir path = Directory.create path

    /// <summary>
    /// Like "cp -r" in a shell. Copies a file or directory recursively.
    /// </summary>
    /// <param name="src">The source</param>
    /// <param name="dest">The destination</param>
    let cp_r src dest =
        if Directory.Exists src then CopyDir dest src (fun _ -> true)
        else CopyFile dest src

    /// Like "cp" in a shell. Copies a single file.
    /// <param name="src">The source</param>
    /// <param name="dest">The destination</param>
    let cp src dest = CopyFile dest src

    /// Changes working directory
    let chdir path = Directory.SetCurrentDirectory path

    /// Changes working directory
    let cd path = chdir path

    /// Gets working directory
    let pwd = Directory.GetCurrentDirectory

    /// The stack of directories operated on by pushd and popd
    let private dirStack = new System.Collections.Generic.Stack<string>()

    /// Store the current directory in the directory stack before changing to a new one
    let pushd path =
        dirStack.Push(pwd())
        cd path

    /// Restore the previous directory stored in the stack
    let popd () =
        cd <| dirStack.Pop()

    /// Like "mv" in a shell. Moves/renames a file
    /// <param name="src">The source</param>
    /// <param name="dest">The destination</param>
    let mv src dest = MoveFile src dest



//// //// //// //// Shell/ChangeWatcher.fs

/// This module contains helpers to react to file system events.
namespace Fuze.IO.FileSystem
module ChangeWatcher=

    open System.IO
    open Fuze.Core
    open Fuze.IO
    open System.Threading
    open System

    type FileStatus =
        | Deleted
        | Created
        | Changed

    type FileChange =
        { FullPath : string
          Name : string
          Status : FileStatus }

    type WatchChangesOption =
        { IncludeSubdirectories: bool }

    let private handleWatcherEvents (status : FileStatus) (onChange : FileChange -> unit) (e : FileSystemEventArgs) =
        onChange ({ FullPath = e.FullPath
                    Name = e.Name
                    Status = status })


    /// Watches for changes in the matching files.
    /// Returns an IDisposable which allows to dispose all internally used FileSystemWatchers.
    ///
    /// ## Parameters
    ///  - `onChange` - function to call when a change is detected.
    ///  - `fileIncludes` - The glob pattern for files to watch for changes.
    ///
    /// ## Sample
    ///
    ///     Target.Create "Watch" (fun _ ->
    ///         use watcher = !! "c:/projects/watchDir/*.txt" |> ChangeWatcher.Run (fun changes ->
    ///             // do something
    ///         )
    ///
    ///         System.Console.ReadLine() |> ignore
    ///
    ///         watcher.Dispose() // if you need to cleanup the watcher.
    ///     )
    ///
    let RunWithOptions options (onChange : FileChange seq -> unit) (fileIncludes : IGlobbingPattern) =
        let dirsToWatch = fileIncludes |> GlobbingPattern.GetBaseDirectoryIncludes

        //tracefn "dirs to watch: %A" dirsToWatch

        // we collect changes in a mutable ref cell and wait for a few milliseconds to
        // receive all notifications when the system sends them repetedly or sends multiple
        // updates related to the same file; then we call 'onChange' with all cahnges
        let unNotifiedChanges = ref List.empty<FileChange>
        // when running 'onChange' we ignore all notifications to avoid infinite loops
        let runningHandlers = ref false
        let timerCallback = fun _ ->
            lock unNotifiedChanges (fun () ->
                if not (Seq.isEmpty !unNotifiedChanges) then
                    let changes =
                        !unNotifiedChanges
                        |> Seq.groupBy (fun c -> c.FullPath)
                        |> Seq.map (fun (name, changes) ->
                               changes
                               |> Seq.sortBy (fun c -> c.Status)
                               |> Seq.head)
                    unNotifiedChanges := []
                    try
                        runningHandlers := true
                        onChange changes
                    finally
                        runningHandlers := false )
        // lazy evaluation of timer in order to only start timer once requested
        let timer = Lazy<IDisposable>(Func<IDisposable> (fun ()-> 
            // NOTE: that the timer starts immidiatelly when constructed
            // we could delay this by sending it how many ms it should delay
            // itself
            // The timer here has a period of 50 ms:
            new Timer(timerCallback, Object(), 0, 50) :> IDisposable
            ), LazyThreadSafetyMode.ExecutionAndPublication)

        let acumChanges (fileChange : FileChange) =
            // only record the changes if we are not currently running 'onChange' handler
            if not !runningHandlers && fileIncludes.IsMatch fileChange.FullPath then
                lock unNotifiedChanges (fun () ->
                  unNotifiedChanges := fileChange :: !unNotifiedChanges
                  // start the timer (ignores repeated calls) to trigger events in 50ms
                  (timer.Value |> ignore) )

        let watchers =
            dirsToWatch |> List.map (fun dir ->
                               //tracefn "watching dir: %s" dir

                               let watcher = new FileSystemWatcher(Path.getFullName dir, "*.*")
                               watcher.EnableRaisingEvents <- true
                               watcher.IncludeSubdirectories <- options.IncludeSubdirectories
                               watcher.Changed.Add(handleWatcherEvents Changed acumChanges)
                               watcher.Created.Add(handleWatcherEvents Created acumChanges)
                               watcher.Deleted.Add(handleWatcherEvents Deleted acumChanges)
                               watcher.Renamed.Add(fun (e : RenamedEventArgs) ->
                                   acumChanges { FullPath = e.OldFullPath
                                                 Name = e.OldName
                                                 Status = Deleted }
                                   acumChanges { FullPath = e.FullPath
                                                 Name = e.Name
                                                 Status = Created })
                               watcher)

        { new System.IDisposable with
              member this.Dispose() =
                  for watcher in watchers do
                      watcher.EnableRaisingEvents <- false
                      watcher.Dispose()
                  // only dispose the timer if it has been constructed
                  if timer.IsValueCreated then timer.Value.Dispose() }


    let Run (onChange : FileChange seq -> unit) (fileIncludes : IGlobbingPattern) = RunWithOptions { IncludeSubdirectories = true } onChange fileIncludes



//// //// //// //// Bootstrap/Main.fs


namespace Fuze
module Main=
    [<EntryPoint>]
    let main (vargs :string[]) = 
        TracerA.trace vargs
        zlog vargs
        Core.String.productName() |> zlog
        IO.Shell.pwd() |> zlog
        vargs |> zlog

        0




// printfn ""
